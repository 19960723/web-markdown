## 函数相关
	### 
	call()  第一个是绑定的this指向,后面传入的是参数列表
	apply() 第二个参数是数组
	bind() 返回的是函数, 需要调用(参数)

	### 函数节流与函数防抖
		1. 事件频繁触发可能造成的问题
			- 一些浏览器事件： window.onresize、window.mousemove等, 触发的频率非常高, 会造成界面卡顿
			- 如果向后台发送请求, 频繁触发, 对服务器造成不必要的压力
		2. 如何限制事件处理函数频繁调用
			- 函数节流
			- 函数防抖
		函数节流 (throttle)
			理解:
				- 在函数需要频繁触发时: 函数执行一次后, 只有大于设定的执行周期后才会执行第二次
				- 适合多次事件按时间平均分配触发
			场景:
				- 窗口调整(resize)
				- 页面滚动(scroll)
				- DOM元素的拖拽功能实现 (mousemove)
				- 抢购疯狂点击 (click)
		函数防抖 (debounce)
			理解: 
## 数组相关
	API列表
		- map()  返回一个由回调函数的返回值组成的新数组
		- reduce()  从左到右为每个数组元素执行一次回调函数, 并把上次回调函数的返回值放在一个暂存器中传给下次回调函数, 并返回最后一次回调函数的返回值
		- filter()
		- find()
		- findIndex()
		- every()
		- some()
		- unique1() / unique2() / unique3()
		- concat()
		- slice()
		- flatten() // 数组扁平化 多维数组 => 一维数组 [1, [2, 3, [4, 5]]] => [1, 2,3 ,4,5]
		- chunk() / chunk2() // 数组分块  一维数组 => 二维数组
		- difference() // 数组差集
		- pull()
		- pullAll()
		- drop()
		- dropRight()
	
 
## 对象相关
 
## 字符串相关
 
## 事件流 手写DOM事件监听(带委托)
	- 事件捕获阶段
		从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件
	- 目标阶段
		在目标节点上触发，称为“目标阶段”
	- 事件冒泡阶段
		从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。
		事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层
事件委托
	优点: 
		- 可以大量节省内存占用, 减少事件注册, 比如在ul上代理所有li的click事件就非常棒
		- 可以实现当新增子对象时无需再次对其绑定（动态绑定事件）
	注意:
		- 使用“事件委托”时，并不是说把事件委托给的元素越靠近顶层就越好。事件冒泡的过程也需要耗时，越靠近顶层，事件的”事件传播链”越长，也就越耗时。如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失

 
## 手写ajax请求函数
 
## 手写事件总线
 
## 手写消息订阅与发布
 
## 手写 Promise